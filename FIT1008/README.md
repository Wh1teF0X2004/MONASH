# FIT1008/FIT1054/FIT2085 - INTRODUCTION TO COMPUTER SCIENCE
- Class 2022 Semester 2
- Assessment 1 (20%): MIPS Assembly Program
- Assessment 2 (40%): Object Oriented Programming with Pokemon 
- Assessment 3 (40%): Algorithms with Minecraft
- This unit introduces students to core problem-solving, analytical skills, and methodologies useful for developing flexible, robust, and maintainable software
- Technologies Used: EdStem, Visual Studio Code/PyCharm IDE, Python, MIPS Assembly Language

## Assessment 1
- Individual Assignment
- MIPS Assembly Programming
- To understand the inner workings of a programming language, and understand how a computer analyses information by converting high-level code into assembly code

## Assessment 2
- Team/Group Assignment
- Pokemon Game 
- Code and use Stack, Queue, Set, and SortedList ADTs to solve problems efficiently
- To collaboratively analyse a given problem and evaluate, select, and use suitable readily available implementation of container ADTs (variants of lists, queues, stacks sets) you have learned as part of the solution, to enable you to analyse the best- and worst-case complexity of an algorithm and then apply this knowledge when dealing with the selected ADTs in practice; additionally, to facilitate your understanding of the design, implementation, testing, and potential extension in Python of the aforementioned ADTs and, finally, to improve your skills of producing high-quality, efficient and well-documented code

## Assessment 3
- Team/Group Assignment
- Minecraft Game 
- Code and use Hash Table, BST / AVL, Heap data structures to solve complex problems
- To collaboratively analyse, select and use from the readily available Hash Table, BST or Priority Queue ADTs in solving a given problem, to facilitate your understanding of how the design decisions made for the implementation of the selected ADT affect the performance in practice, to practice manipulating Binary Search Trees (BSTs) and see how that a variant of self-balancing BSTs can be implemented in Python, to develop your skills in theory and practice of recursive sorting algorithms, and, finally, to solidify your knowledge of how best- and worst-case complexity of an algorithm can be analysed in practice
